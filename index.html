<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>輕量科技 - 開箱你的虛擬技術長</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap" rel="stylesheet" />
  <style>
    *,
    *::before,
    *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans TC', sans-serif;
      background: #f5f0eb;
      color: #1a1a1a;
      overflow-x: hidden;
    }

    /* ===== Nav ===== */
    .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 40px;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
    }

    .navbar-logo {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 900;
      font-size: 18px;
      color: #e8491c;
    }

    .navbar-logo svg {
      width: 28px;
      height: 28px;
    }

    .navbar-links {
      display: flex;
      align-items: center;
      gap: 32px;
      list-style: none;
    }

    .navbar-links a {
      text-decoration: none;
      color: #333;
      font-size: 15px;
      font-weight: 500;
      transition: color .2s;
    }

    .navbar-links a:hover {
      color: #e8491c;
    }

    .btn-cta-nav {
      background: #e8491c;
      color: #fff;
      border: none;
      padding: 10px 24px;
      border-radius: 24px;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      transition: background .2s, transform .15s;
    }

    .btn-cta-nav:hover {
      background: #d13d12;
      transform: scale(1.04);
    }

    /* ===== Hero — Scroll-driven image sequence ===== */
    .hero {
      position: relative;
      width: 100%;
      /* 189 frames at 30fps = 6.3s of content.
         300vh gives ~3 viewport heights of scroll room.
         Each vh of scroll ≈ 63 frames → smooth playback. */
      height: 300vh;
    }

    .hero-sticky {
      position: sticky;
      top: 0;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    /* Canvas fills the sticky viewport — no layout shift */
    #hero-canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #f5f0eb;
    }

    /* --- Text overlays --- */
    .hero-overlay {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding-bottom: 8vh;
    }

    .hero-intro {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      width: max-content;
      transition: opacity 0.1s;
    }

    .hero-text {
      text-align: center;
      width: max-content;
      opacity: 0;
      transition: opacity 0.1s;
      pointer-events: auto;
    }

    .hero-title {
      font-size: clamp(36px, 5.5vw, 72px);
      font-weight: 900;
      color: #1a1a1a;
      line-height: 1.25;
      letter-spacing: 0.04em;
      margin-bottom: 12px;
      text-shadow: 0 2px 20px rgba(255, 255, 255, 0.8);
    }

    .hero-subtitle {
      font-size: clamp(16px, 2vw, 22px);
      color: #666;
      font-weight: 400;
      margin-bottom: 28px;
    }

    .hero-intro .hero-subtitle {
      color: #999;
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 0;
    }

    .btn-cta {
      display: inline-block;
      background: #e8491c;
      color: #fff;
      border: none;
      padding: 16px 40px;
      border-radius: 32px;
      font-size: clamp(16px, 1.8vw, 20px);
      font-weight: 700;
      cursor: pointer;
      text-decoration: none;
      transition: background .2s, transform .15s, box-shadow .2s;
      box-shadow: 0 4px 20px rgba(232, 73, 28, 0.3);
    }

    .btn-cta:hover {
      background: #d13d12;
      transform: scale(1.06);
      box-shadow: 0 6px 28px rgba(232, 73, 28, 0.45);
    }

    /* --- Loading indicator --- */
    .hero-loader {
      position: absolute;
      inset: 0;
      z-index: 20;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #f5f0eb;
      transition: opacity 0.4s ease-out;
    }

    .hero-loader.loaded {
      opacity: 0;
      pointer-events: none;
    }

    .loader-bar-track {
      width: 200px;
      height: 3px;
      background: rgba(0, 0, 0, 0.08);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 16px;
    }

    .loader-bar-fill {
      height: 100%;
      width: 0%;
      background: #e8491c;
      border-radius: 2px;
      transition: width 0.15s;
    }

    .loader-text {
      font-size: 14px;
      color: #999;
      margin-top: 8px;
    }

    /* ===== Spacer ===== */
    .content-spacer {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      font-size: 24px;
      color: #aaa;
    }

    /* ===== Mobile ===== */
    @media (max-width: 768px) {
      .navbar {
        padding: 12px 16px;
      }

      .navbar-links {
        display: none;
      }

      .hero-title {
        font-size: clamp(28px, 7vw, 48px);
      }

      .hero-text {
        width: 90vw;
      }
    }
  </style>
</head>

<body>

  <!-- Nav -->
  <nav class="navbar">
    <div class="navbar-logo">
      <svg viewBox="0 0 32 32" fill="none">
        <rect width="32" height="32" rx="6" fill="#e8491c" /><text x="6" y="23" font-size="18" font-weight="900"
          fill="#fff">C</text>
      </svg>
      輕量科技
    </div>
    <ul class="navbar-links">
      <li><a href="#">首頁</a></li>
      <li><a href="#">價格中心</a></li>
      <li><a href="#">產業顧問</a></li>
      <li><a href="#">Log In</a></li>
    </ul>
    <button class="btn-cta-nav">免費諮詢 →</button>
  </nav>

  <!-- Hero: scroll-driven image sequence -->
  <section class="hero" id="hero">
    <div class="hero-sticky">
      <canvas id="hero-canvas"></canvas>

      <!-- Loading overlay -->
      <div class="hero-loader" id="heroLoader">
        <div class="loader-bar-track">
          <div class="loader-bar-fill" id="loaderFill"></div>
        </div>
        <div class="loader-text" id="loaderText">載入中...</div>
      </div>

      <!-- Text overlays -->
      <div class="hero-overlay">
        <!-- Intro text: visible at start, fades on scroll -->
        <div class="hero-intro" id="heroIntro">
          <h1 class="hero-title">開箱你的虛擬技術長</h1>
          <p class="hero-subtitle">向下滾動，開始開箱</p>
        </div>

        <!-- CTA text: appears after animation completes -->
        <div class="hero-text" id="heroText">
          <h1 class="hero-title">開箱你的虛擬技術長</h1>
          <p class="hero-subtitle">當天部署，立即上工</p>
          <a href="#" class="btn-cta">免費諮詢 →</a>
        </div>
      </div>
    </div>
  </section>

  <section class="content-spacer">
    <p>↑ 向上滾動回到 Hero Section</p>
  </section>

  <script>
    (function () {
      'use strict';

      // ─── Configuration ───────────────────────────────────
      const TOTAL_FRAMES = 189;
      const FRAME_PATH = 'assets/hero-frames/frame_';
      const FRAME_EXT = '.png';
      const FRAME_PAD = 4; // frame_0001.png

      // ─── DOM refs ────────────────────────────────────────
      const canvas = document.getElementById('hero-canvas');
      const ctx = canvas.getContext('2d');
      const heroSection = document.getElementById('hero');
      const heroLoader = document.getElementById('heroLoader');
      const loaderFill = document.getElementById('loaderFill');
      const loaderText = document.getElementById('loaderText');
      const heroIntro = document.getElementById('heroIntro');
      const heroText = document.getElementById('heroText');

      // ─── State ───────────────────────────────────────────
      const frames = new Array(TOTAL_FRAMES);
      let loadedCount = 0;
      let currentFrame = -1; // track which frame is drawn to avoid redundant draws
      let scrollY = 0;
      let ticking = false;

      // ─── Helpers ─────────────────────────────────────────
      function padNumber(n, len) {
        return String(n).padStart(len, '0');
      }

      function frameSrc(index) {
        // index is 0-based; filenames are 1-based
        return FRAME_PATH + padNumber(index + 1, FRAME_PAD) + FRAME_EXT;
      }

      // ─── Canvas sizing (handles devicePixelRatio) ───────
      function sizeCanvas() {
        const rect = canvas.parentElement.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Redraw current frame after resize
        if (currentFrame >= 0 && frames[currentFrame]) {
          drawFrame(currentFrame);
        }
      }

      // ─── Draw a frame (object-fit: cover behavior) ──────
      function drawFrame(index) {
        const img = frames[index];
        if (!img) return;

        const cw = canvas.width / (Math.min(window.devicePixelRatio || 1, 2));
        const ch = canvas.height / (Math.min(window.devicePixelRatio || 1, 2));
        const iw = img.naturalWidth;
        const ih = img.naturalHeight;

        // Calculate "object-fit: cover" dimensions
        const canvasRatio = cw / ch;
        const imgRatio = iw / ih;

        let drawW, drawH, offsetX, offsetY;
        if (imgRatio > canvasRatio) {
          // Image wider than canvas → fit height, crop sides
          drawH = ch;
          drawW = ch * imgRatio;
          offsetX = (cw - drawW) / 2;
          offsetY = 0;
        } else {
          // Image taller than canvas → fit width, crop top/bottom
          drawW = cw;
          drawH = cw / imgRatio;
          offsetX = 0;
          offsetY = (ch - drawH) / 2;
        }

        ctx.clearRect(0, 0, cw, ch);
        ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
        currentFrame = index;
      }

      // ─── Scroll → frame mapping (linear, no easing) ─────
      function getFrameIndex() {
        const heroRect = heroSection.getBoundingClientRect();
        const sectionTop = -heroRect.top; // how far we've scrolled into the section
        const scrollableHeight = heroSection.offsetHeight - window.innerHeight;

        if (scrollableHeight <= 0) return 0;

        const progress = Math.max(0, Math.min(1, sectionTop / scrollableHeight));
        return Math.min(Math.floor(progress * TOTAL_FRAMES), TOTAL_FRAMES - 1);
      }

      // ─── Text overlay control ────────────────────────────
      function updateTextOverlays(frameIndex) {
        const progress = frameIndex / (TOTAL_FRAMES - 1);

        // Intro text: fade out in first 10% of scroll
        const introOpacity = Math.max(0, 1 - progress / 0.1);
        heroIntro.style.opacity = introOpacity;

        // CTA text: fade in during last 15% of scroll
        const ctaOpacity = Math.max(0, Math.min(1, (progress - 0.85) / 0.15));
        heroText.style.opacity = ctaOpacity;
      }

      // ─── Render loop (rAF-gated) ────────────────────────
      function onScroll() {
        scrollY = window.scrollY;
        if (!ticking) {
          ticking = true;
          requestAnimationFrame(render);
        }
      }

      function render() {
        ticking = false;
        const frameIndex = getFrameIndex();
        if (frameIndex !== currentFrame && frames[frameIndex]) {
          drawFrame(frameIndex);
        }
        updateTextOverlays(frameIndex);
      }

      // ─── Preload strategy ───────────────────────────────
      // 1. Load first frame immediately for instant display
      // 2. Load remaining frames in parallel batches
      function preloadFrames() {
        return new Promise((resolve) => {
          const BATCH_SIZE = 10; // concurrent downloads

          function loadImage(index) {
            return new Promise((res) => {
              const img = new Image();
              img.onload = () => {
                frames[index] = img;
                loadedCount++;
                updateLoader();
                // Draw first frame as soon as it loads
                if (index === 0 && currentFrame < 0) {
                  drawFrame(0);
                }
                res();
              };
              img.onerror = () => {
                loadedCount++;
                updateLoader();
                res(); // skip broken frames
              };
              img.src = frameSrc(index);
            });
          }

          function updateLoader() {
            const pct = Math.round((loadedCount / TOTAL_FRAMES) * 100);
            loaderFill.style.width = pct + '%';
            loaderText.textContent = pct + '%';

            if (loadedCount >= TOTAL_FRAMES) {
              heroLoader.classList.add('loaded');
              resolve();
            }
          }

          // Load in batches to avoid overwhelming the browser
          async function loadAll() {
            // First frame is priority
            await loadImage(0);

            // Remaining frames in parallel batches
            const remaining = [];
            for (let i = 1; i < TOTAL_FRAMES; i++) remaining.push(i);

            for (let i = 0; i < remaining.length; i += BATCH_SIZE) {
              const batch = remaining.slice(i, i + BATCH_SIZE);
              await Promise.all(batch.map(loadImage));
            }
          }

          loadAll();
        });
      }

      // ─── Init ────────────────────────────────────────────
      function init() {
        sizeCanvas();
        window.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', sizeCanvas);
        preloadFrames().then(() => {
          // Ensure correct frame is shown after all loaded
          render();
        });
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>

</html>
